.\" Man page generated from reStructuredText.
.
.TH "MPI_FILE_READ_ORDERED_END" "3" "Jan 11, 2022" "" "Open MPI"
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.sp
\fI\%MPI_File_read_ordered_end\fP \- Reads a file at a location specified by
a shared file pointer; ending part of a split collective routine
(blocking).
.SH SYNTAX
.SS C Syntax
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mpi.h>
int MPI_File_read_ordered_end(MPI_File fh, void *buf,
     MPI_Status *status)
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Fortran Syntax
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
USE MPI
! or the older form: INCLUDE \(aqmpif.h\(aq
MPI_FILE_READ_ORDERED_END(FH, BUF, STATUS, IERROR)
     <type>  BUF(*)
     INTEGER FH, STATUS(MPI_STATUS_SIZE), IERROR
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Fortran 2008 Syntax
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
USE mpi_f08
MPI_File_read_ordered_end(fh, buf, status, ierror)
     TYPE(MPI_File), INTENT(IN) :: fh
     TYPE(*), DIMENSION(..), ASYNCHRONOUS :: buf
     TYPE(MPI_Status) :: status
     INTEGER, OPTIONAL, INTENT(OUT) :: ierror
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
INPUT/OUTPUT PARAMETER
\-\-\-\-\-/\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
* \fBfh\fP: File handle (handle).
.SH OUTPUT PARAMETERS
.INDENT 0.0
.IP \(bu 2
\fBbuf\fP: Initial address of buffer (choice).
.IP \(bu 2
\fBstatus\fP: Status object (status).
.IP \(bu 2
\fBIERROR\fP: Fortran only: Error status (integer).
.UNINDENT
.SH DESCRIPTION
.sp
\fI\%MPI_File_read_ordered_end\fP is the ending part of a split collective
routine that must be called by all processes in the communicator group
associated with the file handle \fIfh.\fP MPI_File_rad_ordered_end blocks
until the operation initiated by MPI_File_read_ordered_begin completes.
It attempts to read the file associated with \fIfh\fP into the user\(aqs buffer
\fIbuf.\fP The shared file pointer is updated by the amounts of data
requested by all processes of the group. For each process, the location
in the file at which data is read is the position at which the shared
file pointer would be after all processes whose ranks within the group
are less than that of this process had read their data.
.SH NOTES
.sp
All the nonblocking collective routines for data access are "split" into
two routines, each with _begin or _end as a suffix. These split
collective routines are subject to the semantic rules described in
Section 9.4.5 of the MPI\-2 standard.
.SH ERRORS
.sp
Almost all MPI routines return an error value; C routines as the value
of the function and Fortran routines in the last argument.
.sp
Before the error value is returned, the current MPI error handler is
called. For MPI I/O function errors, the default error handler is set to
MPI_ERRORS_RETURN. The error handler may be changed with
MPI_File_set_errhandler; the predefined error handler
MPI_ERRORS_ARE_FATAL may be used to make I/O errors fatal. Note that MPI
does not guarantee that an MPI program can continue past an error.
.SH COPYRIGHT
2020, The Open MPI Community
.\" Generated by docutils manpage writer.
.
