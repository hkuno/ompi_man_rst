.\" Man page generated from reStructuredText.
.
.TH "MPI_INIT_THREAD" "3" "Jan 05, 2022" "" "Open MPI"
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.sp
\fI\%MPI_Init_thread\fP \- Initializes the MPI execution environment
.SH SYNTAX
.SS C Syntax
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mpi.h>
int MPI_Init_thread(int *argc, char ***argv,
     int required, int *provided)
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Fortran Syntax
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
USE MPI
! or the older form: INCLUDE \(aqmpif.h\(aq
MPI_INIT_THREAD(REQUIRED, PROVIDED, IERROR)
     INTEGER REQUIRED, PROVIDED, IERROR
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Fortran 2008 Syntax
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
USE mpi_f08
MPI_Init_thread(required, provided, ierror)
     INTEGER, INTENT(IN) :: required
     INTEGER, INTENT(OUT) :: provided
     INTEGER, OPTIONAL, INTENT(OUT) :: ierror
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
INPUT PARAMETERS
\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-
.INDENT 0.0
.IP \(bu 2
\fBargc\fP: C only: Pointer to the number of arguments.
.IP \(bu 2
\fBargv\fP: C only: Argument vector.
.IP \(bu 2
\fBrequired\fP: Desired level of thread support (integer).
.UNINDENT
.sp
OUTPUT PARAMETERS
\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-
.INDENT 0.0
.IP \(bu 2
\fBprovided\fP: Available level of thread support (integer).
.IP \(bu 2
\fBIERROR\fP: Fortran only: Error status (integer).
.UNINDENT
.SH DESCRIPTION
.sp
This routine, or MPI_Init, must be called before most other MPI routines
are called. There are a small number of exceptions, such as
MPI_Initialized and MPI_Finalized\&. MPI can be initialized at most once;
subsequent calls to MPI_Init or \fI\%MPI_Init_thread\fP are erroneous.
.sp
\fI\%MPI_Init_thread\fP, as compared to MPI_Init, has a provision to request a
certain level of thread support in \fIrequired\fP:
.INDENT 0.0
.TP
.B MPI_THREAD_SINGLE
Only one thread will execute.
.TP
.B MPI_THREAD_FUNNELED
If the process is multithreaded, only the thread that called
\fI\%MPI_Init_thread\fP will make MPI calls.
.TP
.B MPI_THREAD_SERIALIZED
If the process is multithreaded, only one thread will make MPI
library calls at one time.
.TP
.B MPI_THREAD_MULTIPLE
If the process is multithreaded, multiple threads may call MPI at
once with no restrictions.
.UNINDENT
.sp
The level of thread support available to the program is set in
\fIprovided\fP\&. In Open MPI, the value is dependent on how the library was
configured and built. Note that there is no guarantee that \fIprovided\fP
will be greater than or equal to \fIrequired\fP\&.
.sp
Also note that calling \fI\%MPI_Init_thread\fP with a \fIrequired\fP value of
MPI_THREAD_SINGLE is equivalent to calling MPI_Init\&.
.sp
All MPI programs must contain a call to MPI_Init or \fI\%MPI_Init_thread\fP\&.
Open MPI accepts the C \fIargc\fP and \fIargv\fP arguments to main, but neither
modifies, interprets, nor distributes them:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
        /* declare variables */
        MPI_Init_thread(&argc, &argv, req, &prov);
        /* parse arguments */
        /* main program */
        MPI_Finalize();
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SH NOTES
.sp
The Fortran version does not have provisions for \fIargc\fP and \fIargv\fP and
takes only IERROR.
.sp
It is the caller\(aqs responsibility to check the value of \fIprovided\fP, as
it may be less than what was requested in \fIrequired\fP\&.
.sp
The MPI Standard does not say what a program can do before an
\fI\%MPI_Init_thread\fP or after an MPI_Finalize\&. In the Open MPI
implementation, it should do as little as possible. In particular, avoid
anything that changes the external state of the program, such as opening
files, reading standard input, or writing to standard output.
.SS MPI_THREAD_MULTIPLE Support
.sp
MPI_THREAD_MULTIPLE support is included if the environment in which Open
MPI was built supports threading. You can check the output of
\fBompi_info\fP(1) to see if Open MPI has MPI_THREAD_MULTIPLE support:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
shell$ ompi_info | grep "Thread support"
          Thread support: posix (MPI_THREAD_MULTIPLE: yes, OPAL support: yes, OMPI progress: no, Event lib: yes)
shell$
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The "MPI_THREAD_MULTIPLE: yes" portion of the above output indicates
that Open MPI was compiled with MPI_THREAD_MULTIPLE support.
.sp
Note that there is a small performance penalty for using
MPI_THREAD_MULTIPLE support; latencies for short messages will be higher
as compared to when using MPI_THREAD_SINGLE, for example.
.SH ERRORS
.sp
Almost all MPI routines return an error value; C routines as the value
of the function and Fortran routines in the last argument.
.sp
Before the error value is returned, the current MPI error handler is
called. By default, this error handler aborts the MPI job, except for
I/O function errors. The error handler may be changed with
MPI_Comm_set_errhandler; the predefined error handler MPI_ERRORS_RETURN
may be used to cause error values to be returned. Note that MPI does not
guarantee that an MPI program can continue past an error.
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
MPI_Init    MPI_Initialized    MPI_Finalize    MPI_Finalized
.UNINDENT
.UNINDENT
.SH COPYRIGHT
2020, The Open MPI Community
.\" Generated by docutils manpage writer.
.
