.\" Man page generated from reStructuredText.
.
.TH "MPI_FILE_WRITE_ALL_BEGIN" "3" "Jan 05, 2022" "" "Open MPI"
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.sp
\fI\%MPI_File_write_all_begin\fP \- Writes a file starting at the locations
specified by individual file pointers; beginning part of a split
collective routine (nonblocking).
.SH SYNTAX
.SS C Syntax
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mpi.h>
int MPI_File_write_all_begin(MPI_File fh, const void *buf,
     int count, MPI_Datatype datatype)
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Fortran Syntax
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
USE MPI
! or the older form: INCLUDE \(aqmpif.h\(aq
MPI_FILE_WRITE_ALL_BEGIN(FH, BUF, COUNT, DATATYPE, IERROR)
     <type>  BUF(*)
     INTEGER FH, COUNT, DATATYPE, IERROR
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Fortran 2008 Syntax
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
USE mpi_f08
MPI_File_write_all_begin(fh, buf, count, datatype, ierror)
     TYPE(MPI_File), INTENT(IN) :: fh
     TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: buf
     INTEGER, INTENT(IN) :: count
     TYPE(MPI_Datatype), INTENT(IN) :: datatype
     INTEGER, OPTIONAL, INTENT(OUT) :: ierror
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
INPUT/OUTPUT PARAMETER
\-\-\-\-\-/\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-
.INDENT 0.0
.IP \(bu 2
\fBfh\fP: File handle (handle).
.UNINDENT
.sp
INPUT PARAMETERS
\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-
.INDENT 0.0
.IP \(bu 2
\fBbuf\fP: Initial address of buffer (choice).
.IP \(bu 2
\fBcount\fP: Number of elements in buffer (integer).
.IP \(bu 2
\fBdatatype\fP: Data type of each buffer element (handle).
.UNINDENT
.sp
OUTPUT PARAMETER
\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-
.INDENT 0.0
.IP \(bu 2
\fBIERROR\fP: Fortran only: Error status (integer).
.UNINDENT
.SH DESCRIPTION
.sp
\fI\%MPI_File_write_all_begin\fP is the beginning part of a split collective,
nonblocking routine that attempts to write into the file associated with
\fIfh\fP (at the current individual file pointer position maintained by the
system) a total number of \fIcount\fP data items having \fIdatatype\fP type from
the user\(aqs buffer \fIbuf.\fP The data is written into those parts of the
file specified by the current view.
.SH NOTES
.sp
All the nonblocking collective routines for data access are "split" into
two routines, each with _begin or _end as a suffix. These split
collective routines are subject to the semantic rules described in
Section 9.4.5 of the MPI\-2 standard.
.SH ERRORS
.sp
Almost all MPI routines return an error value; C routines as the value
of the function and Fortran routines in the last argument.
.sp
Before the error value is returned, the current MPI error handler is
called. For MPI I/O function errors, the default error handler is set to
MPI_ERRORS_RETURN. The error handler may be changed with
MPI_File_set_errhandler; the predefined error handler
MPI_ERRORS_ARE_FATAL may be used to make I/O errors fatal. Note that MPI
does not guarantee that an MPI program can continue past an error.
.SH COPYRIGHT
2020, The Open MPI Community
.\" Generated by docutils manpage writer.
.
